---
title: "Model "
author: "Greg Macfarlane"
date: "6/17/2019"
output: html_document
---

```{r setup}
knitr::opts_chunk$set(cache = TRUE)
library(tidyverse)
library(broom)
library(sf)
library(spdep)
library(spatialreg)
library(texreg)
library(here)
library(dotwhisker)

view_kable <- function(x){
  if(isTRUE(getOption('knitr.in.progress'))){
    x
  } else {
    tab <- paste(capture.output(x))
    tf <- tempfile(fileext = ".html")
    writeLines(tab, tf)
    viewer <- getOption("viewer")
    viewer(tf)
  }
}
```

In this document we attempt to determine the correct spatial weights matrix and
spatial spillovers specification. There are a few different questions we need
to answer in this analysis:

  - What is the most likely $W$?
  - What is the econometrically "correct" specification of the model?
  - Does this change depending on which matrix we end up using?
  - Does this change depending on the dependent variable?

## Spatial Weights Matrix
A spatial econometric model represents the connections and spillovers between 
regions with a matrix $W$. There are a few different ways to represent this
matrix, but we will consider the simplest. First, let's load the shapefile of 
the regions with the accessibility logsums attached.

```{r bg_access}
bg_access <- read_rds("data/bg_access.rds")
```

The accessibility is calculated at the block group level, but the other information
(health, demographics) is available only at the tract level. 

```{r tracts}
mydata <- bg_access %>% 
  dplyr::mutate(tract = substr(geoid, 0, 11)) %>%
  left_join(
    read_rds("data/tracts.rds") %>%
      st_set_geometry(NULL),
    by = c("tract" = "geoid")
  ) %>%
  filter(!is.na(households))
```


### Contiguity weights

Other investigations will often use a contiguity matrix where adjacent or
bordering regions are considered neighbors.

```{r Wcontig}
areas_adj <- poly2nb(mydata)
Wcontig <- nb2listw(areas_adj, style = "W", zero.policy = TRUE)
print(Wcontig, zero.policy = TRUE)
```


## Spatial Econometric Selection

There is some uncertainty over which model we should use for interpretation. 
Part of the issue is that there is both an econometric / statistical approach as
well as a intuition / behavioral understanding approach.

In the intutive approach, it is easy to understand why physical activity and 
obesity rates may be correlated in space. Individuals in neighboring tracts are
likely to share cultural and experiential attributes that influence physical
activity rates, and obesity. They eat at the same restaurants, attend the same
schools, etc. This suggests that a model with correlated error components (the SEM),
$$y = X\beta + u; u = \lambda W u + \epsilon$$
is most applicable. It is less understandable why a dependency spillover (like the SAR),
$$y = \rho W y + X\beta + \epsilon$$
is warranted. This would imply that individuals in tract $i$ are obese *because* 
individuals in tract $j$ are obese. It may be more likely that attributes of neighboring
zones affect the outcome variable, as in the SLX model,
$$y = X\beta + \gamma W X + \epsilon$$
and the SDEM model,
$$y = X\beta + \gamma W X + u; u = \lambda W u + \epsilon$$
This kind of model suggests that the socioeconomic attributes of surrounding zones
can affect the physical activity rates or obesity in the target zone, but that
the outcome of a particular obesity rate is locally determined.

The final model is the SDM, a complete linear combination of the SAR and SEM,
$$y = \rho W y + X\beta + \gamma W X + \epsilon$$
This would imply that obesity is a function of socioeconomic factors in the
local and neighboring zones, *and* the obesity in those neighboring zones. This 
seems to be a stretch.

But here's where the econometric argument comes in. If the true DGP is an SEM
and you use an OLS model to predict it, the coefficients will be unbiased but 
with incorrectly small standard errors, affecting hypothesis tests. If the true 
DGP is SDM but you use an OLS or SEM model, you have a missing variable and your
estimates are inconsistent. Thus it is possible to test for whether the correct
specification has been achieved independently of the rationale inherent in the
model specification.

### OLS vs SEM
The base formula includes all of the tract-level covariates.

```{r base_formula}
base_formula <- formula(
  ~ log(density) + log(income) +
    fulltime + college + single +
    youth + young_adults + seniors + # need to leave out a category for collinearity
    black + asian + hispanic + other)
```

Let's begin by estimating the OLS and SEM versions of the physical activity model
as a function of the socioeconomic attributes (X) and the accesibility.

$$PhysAct = X\beta + \beta_{access}*access + u; u = \lambda W u + \epsilon$$
We will consider both spatial weights matrices.

```{r ols_vs_sem}
access_ols <- lm(update(base_formula, physact ~ . + access_ls), data = mydata)
access_sem_wc <- errorsarlm(update(base_formula, physact ~ . + access_ls),
                            data = mydata, listw = Wcontig, zero.policy = TRUE)

ols_vs_sem <- list("OLS" = access_ols, "SEM" = access_sem_wc)
```

In this case the null hypothesis is that both models (the OLS and SEM) are equally
good representations of the underlying DGP (or at least provide consistent estimates
of $\beta$). This suggests a Hausman-style test of the equality of the parameter 
coefficients,
$$H = (\beta_1 - \beta_2)^T (\Sigma_2 - \Sigma_1)^{-1} (\beta_1 - \beta_2)$$
where the null hypothesis is that $\beta_{OLS} = \beta_{SEM}$

```{r sp_hausman}
sp_hausman <- function(ols, sem) {
  b1 <- ols$coefficients
  b2 <- sem$coefficients
  db <- b1 - b2
  
  V1 <- vcov(ols)
  V2 <- vcov(sem)[rownames(V1), colnames(V1)]
  dV <- V2 - V1
  
  tibble(
    Hstat = t(db) %*% MASS::ginv(dV) %*% db, 
    "p-value" = pchisq(Hstat, df = Matrix::rankMatrix(dV))
  )
}

sp_hausman(access_ols, access_sem_wc)
```

In both cases, we reject the null hypothesis that the coefficient estimates are
the same and conclude that the true DGP is not likely OLS or SEM. Still, it's worth
considering just how far apart the estimates are.

```{r tidy.sarlm}
tidy.sarlm <- function(x){
  s <- summary(x)
  df <- length(s$residuals) - length(s$coefficients) - 1
  tibble(
    term = gsub("[\\(\\)]", "\\.", rownames(s$Coef)),
    estimate = s$Coef[,1],
    std.error = s$Coef[,2],
    statistic = estimate / std.error,
    p.value = 2*(pt(abs(statistic), Inf, lower.tail = FALSE))
  )
}
lapply(ols_vs_sem, tidy) %>%
  bind_rows(.id = "model") %>%
  dwplot() + scale_x_continuous(limits = c(-0.3, 1))
```

In the plot above `log(income)` is considerably larger than other variables but
the estimates from the three models for that coefficient are similar. That said, 
the only estimates that differ significantly between the OLS and SEM model are
  - `log(density)`: in the case of the SEM models the coefficient is not a significant predictor.
  - `college`: in the SEM models the coefficient takes a different sign with
  physical activity *increasing* with college education.
  - `access_ls`: this is our variable of interest.
  
I'm curious what happens when we remove density from the base model.

```{r nodensity}
# take log(density) out of the bare access model
nodensity <- lapply(ols_vs_sem, function(model) {
  update(model, . ~ . - log(density))
})
lapply(nodensity, tidy) %>%
  bind_rows(.id = "model") %>%
  dwplot() + scale_x_continuous(limits = c(-0.3, 1))
```

Basically the same thing. It's worth looking at whether the same thing is happening
in the obesity model.

```{r obesity_sem}
obesity_sem <- lapply(ols_vs_sem, function(model) {
  update(model, obesity ~ . + physact)
})
lapply(obesity_sem, tidy) %>%
  bind_rows(.id = "model") %>%
  dwplot() 
```

Yup. Okay, given that, the question is whether adding lagged
variables $\gamma W X$ to the model will resolve the discrepancy.

### SLX vs SDEM

The same basic logic applies to the SLX and SDEM models; if there is no dependence
relationship among the $y$ variables, then the SLX and SDEM will have unbiased
estimates of $\beta$ and $\gamma$.

```{r access_slx}
access_slx_wc <- lmSLX(update(base_formula, physact ~ . + access_ls), 
                       data = mydata, listw = Wcontig, zero.policy = TRUE)
access_sdem_wc <- errorsarlm(update(base_formula, physact ~ . + access_ls),
                            data = mydata, listw = Wcontig, zero.policy = TRUE, 
                            Durbin = TRUE)
slx_vs_sdem <- list(
  "SDEM" = access_sdem_wc,
  "SLX" = access_slx_wc
)
```

As before, we can try a Hausman-style test.
```{r slx_hausman}
slx_hausman <- function(slx, sdem) {
  b1 <- slx$coefficients
  b2 <- sdem$coefficients
  db <- b1 - b2
  
  V1 <- vcov(slx)
  V2 <- vcov(sdem)[names(b2), names(b2) ]
  dV <- V2 - V1
  
  tibble(
    Hstat = t(db) %*% MASS::ginv(dV) %*% db, 
    "p-value" = pchisq(Hstat, df = Matrix::rankMatrix(dV), lower.tail = FALSE)
  )
}
slx_hausman(access_slx_wc, access_sdem_wc)
```

Let's look at the tidied dataframes instead.

```{r visual_compare}
lapply(slx_vs_sdem, tidy) %>%
  bind_rows(.id = "model") %>%
  dwplot() + scale_x_continuous(limits = c(-0.5, 0.6))
lapply(slx_vs_sdem, tidy) %>%
  bind_rows(.id = "model") %>%
  dwplot() 
```

Hey! This looks good! The direct effects are basically the same in all four models,
with some disagreement in some lagged regressors. Unfortunately for this study,
the access logsum variable is not directly significant. But this does point to a 
potential way forwards: what if we don't lag that variable?

```{r lagged_vars}
contiglagged_vars <- mydata %>%
  as_tibble() %>%
  transmute_at(
    vars(density, income, fulltime, college, single, youth, young_adults, seniors, black, asian, hispanic, other, physact),
    ~lag.listw(Wcontig, .)
  ) %>%
  mutate(geoid = mydata$geoid) %>%
  dplyr::select(geoid, everything())

names(contiglagged_vars)[-1] <- str_c("lag.", names(contiglagged_vars)[-1])
contiglagged_data <- mydata %>% left_join(contiglagged_vars, by = "geoid")
```

This is a good model. Access is significant, the direct effects are significant
and mostly in the correct sign, lagged variables are also significant. 

```{r nolag_access}
access_slx_wc <- lm(update(
  base_formula, physact ~ . +  log(lag.density) + log(lag.income) + 
    lag.fulltime + lag.college + lag.single + lag.youth +  lag.young_adults + 
    lag.seniors + lag.black + lag.asian + lag.hispanic + lag.other + access_ls),
  data = contiglagged_data)

access_sdem_wc <- errorsarlm(update(
  base_formula, physact ~ . +  log(lag.density) + log(lag.income) + 
    lag.fulltime + lag.college + lag.single + lag.youth +  lag.young_adults + 
    lag.seniors + lag.black + lag.asian + lag.hispanic + lag.other + access_ls), 
  data = contiglagged_data, listw = Wcontig, zero.policy = TRUE)
```


```{r nolag_access_tests}
slx_hausman(access_slx_wc, access_sdem_wc)
slx1_vs_sdem1 <- list("SLX" = access_slx_wc, "SDEM" = access_sdem_wc)

screenreg(slx1_vs_sdem1, ci.force = TRUE)
```


## Physical activity models
Now to estimate the other models we are considering in the analysis.

```{r estimate_sdems}
base_sdem <- update(access_sdem_wc, formula = . ~ . - access_ls,
                    data = contiglagged_data, listw = Wcontig, zero.policy = TRUE)

# estimate models
pa_access_sdm <- access_sdem_wc
pa_multi_sdm   <- update(base_sdem, .~ . + multi_ls)
```


Now we can add all four access measures to the formula one after the other.

```{r access_sdm}
pa_models <- list("Base"        = base_sdem,
                  "Logsum"      = pa_access_sdm,
                  "Attributes"  = pa_multi_sdm)
```

```{r screen_pa_models, results = "asis"}
view_kable(
htmlreg(pa_models, digits = 4, table = FALSE, single.row = TRUE, 
                   caption.above = TRUE, caption = "Spatial Error Model ",
          stars = c(0.001, 0.01, 0.05, 0.1) )
)
```


```{r obesity_models}
obesity_models <- lapply(pa_models, function(model){
  update(update(model, obesity ~ . + physact + lag.physact))
})

names(obesity_models) <- names(pa_models)
```

```{r screen_obesity_models, results="asis"}
view_kable(
  htmlreg(obesity_models, digits = 3, table = FALSE, single.row = TRUE, 
                   caption.above = TRUE, caption = "Spatial Error Model ",
          stars = c(0.001, 0.01, 0.05, 0.1) )
)
```


```{r models}
write_rds(slx1_vs_sdem1, "data/slx_vs_sdem.rds")
write_rds(pa_models, "data/pa_models.rds")
write_rds(obesity_models, "data/obesity_models.rds")
```

