---
title: "Logsums"
author: "Greg Macfarlane"
date: "6/7/2019"
output: html_document
---

```{r setup}
knitr::opts_chunk$set(cache = TRUE)
library(tidyverse)
library(sf)
library(spdep)
library(leaflet)
library(lubridate)
library(VGAM)
```

In this document we calculate the distance between each tract in New York City 
and each park to help calculate a logsum-based measure of accessibility. We 
cleaned and gathered the data in the previous two pages.

```{r load}
open_spaces <- read_rds("data/open_spaces.rds")
tracts <- read_rds("data/tracts.rds")
```

We are going to do a point-to-polygon distance calculation. The geometric centroid
of the tracts are not satisfying, so we will use the population-weighted centroid
instead.

```{r pop_weighted_centroids}
pop_weighted_centroids <- tracts %>% tbl_df() %>%
  dplyr::select(geoid) %>%
  left_join(
    read_csv("https://www2.census.gov/geo/docs/reference/cenpop2010/tract/CenPop2010_Mean_TR36.txt") %>%
      transmute(geoid = str_c(STATEFP, COUNTYFP, TRACTCE), LATITUDE, LONGITUDE)
  ) %>%
  # convert to sf and project into the feet-based projection used in the
  # parks dataset.
  st_as_sf(crs = 4326, coords = c("LONGITUDE", "LATITUDE")) %>%
  st_transform(3628) %>%
  write_rds("data/pop_weighted_centroids.rds")

```

The population-weighted centroid also serves as the orientation for the spatial
weights matrix.

```{r W}
# determine which tracts are neighbors of each other. Need to be less than
# 1.8 miles away from the centroids
tracts.dnn <- dnearneigh(as(pop_weighted_centroids, "Spatial"), 0, 1.8 * 5280)
# calculate the inverse distance to use as a weight on the neighbor connection
tract_dists <- nbdists(tracts.dnn, as(pop_weighted_centroids, "Spatial"))
write_rds(tract_dists, "data/tract_distances.rds")
```




## Distances
We want to make sure that the distance between a park and a tract centroid is
based on the edge of the polygon instead of the centroid thereof, so that spaces
at the corners of Central park, for instance, don't appear as longer than they should be.
It seems that things are working appropriately.

```{r test_measurement}
central_park <- open_spaces %>% filter(name == "Central Park")
pop_weighted_centroids$central_park <- log(as.numeric(st_distance(pop_weighted_centroids, central_park)))

dmeasure <- colorNumeric(palette = "Blues", domain = pop_weighted_centroids$central_park)
leaflet(pop_weighted_centroids %>% st_transform(4326)) %>%
  addProviderTiles(providers$Esri.WorldGrayCanvas) %>%
  addCircleMarkers(color = ~dmeasure(central_park))
```

Now we can calculate the distance from every park to every tract population
centroid, and write the distances and neighbors weights matrix to a file.
```{r distances}
# distances from all tract centroids to all parks
distances <- st_distance(pop_weighted_centroids, open_spaces, byid = TRUE) %>%
  units::set_units(miles) %>%
  units::drop_units()

# assert that a tract must be at least 1/10 mile from a park
distances <- pmax(distances, 0.1)

write_rds(distances, "data/distances.rds")
```




## Logsums

Here's the function we use to calculate the logsums. 
```{r calculate_park_logsums}
source("R/logsums.R")
print(calculate_park_logsums)
```

We use this function with asserted beta values of -1.98 and 0.3 to calculate the
accessibility logsum.
```{r logsum_vars}
open_spaces$acres <- as.numeric(open_spaces$acres)
logsum_vars <- tracts %>%
  transmute(
    geoid, 
    # Log-sum based utilities, without and with Twitter data
    access_ls = calculate_park_logsums(
      log(distances) * -1.768, log(open_spaces$acres) * 0.373
    ),
    tweets_ls = calculate_park_logsums(
      log(distances) * -1.768, 
      log(open_spaces$acres) * 0.373 + 
        0.1 * yeo.johnson(open_spaces$tweet_count, lambda = 0)
    ),
    multi_ls = calculate_park_logsums(
      log(distances) * -1.768, 
      log(open_spaces$acres) * 0.373 + 
        open_spaces$trails * 0.99 + 
        open_spaces$playgrounds * 0.26 + 
        open_spaces$courts * 0.43
    ),
  ) %>%
  mutate_at(
    vars(ends_with("_ls")),
    # Normalize the logsum onto the Z-scale
    list(~ (. - mean(.) ) / sd(.))
  ) %>%
  st_set_geometry(NULL) %>%
  as_tibble()
```

We are also interested in looking at what happens when the tracts are within a 
10-minute walk of a park, the threshold established by the Trust for Public Lands.
```{r nyc10mw}
access_10mw <- st_read("data/nyc_10mw.geojson") %>%
  summarise(d = 1)

inside_access <- pop_weighted_centroids %>%
  st_transform(4326) %>%
  st_join(access_10mw, st_intersects) %>%
  filter(!is.na(d))

tracts_access <- tracts %>%
  left_join(logsum_vars, by = "geoid") %>%
  mutate(walk_10 = ifelse(geoid %in% inside_access$geoid, TRUE, FALSE)) %>%
  write_rds("data/tracts_access.rds")
```

Here's a map of the values. Note that there is also a shiny app in this project that
allows the user to set different values for the logsum parameters.
```{r access_map}
# this interactive map is much easier to create and explore
pal <- colorQuantile("GnBu", c(tracts_access$access_ls, tracts_access$multi_ls), n = 5)
bin <- colorFactor("Dark2", tracts_access$walk_10)
leaflet(tracts_access) %>%
  addProviderTiles(providers$Esri.WorldGrayCanvas) %>%
  addPolygons(group = "access", color = ~ pal(access_ls),
              label = ~as.character(round(access_ls, 2))) %>%
  addPolygons(group = "tweets", color = ~ pal(tweets_ls),
              label = ~as.character(round(tweets_ls, 2))) %>%
  addPolygons(group = "Kinner", color = ~ pal(multi_ls),
              label = ~as.character(round(multi_ls, 2))) %>%
  addPolygons(group = "10-minute walk", color = ~ bin(walk_10)) %>%
  addLayersControl(baseGroups = c("access", "tweets", "Kinner", "10-minute walk"))
```

